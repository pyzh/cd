.TH string 3 "stdlib 3.3" "Ericsson AB" "Erlang Module Definition"
.SH NAME
string \- String processing functions.
.SH DESCRIPTION
.LP
This module provides functions for string processing\&.
.SH EXPORTS
.LP
.nf

.B
centre(String, Number) -> Centered
.br
.fi
.br
.nf

.B
centre(String, Number, Character) -> Centered
.br
.fi
.br
.RS
.LP
Types:

.RS 3
String = Centered = string()
.br
Number = integer() >= 0
.br
Character = char()
.br
.RE
.RE
.RS
.LP
Returns a string, where \fIString\fR\& is centered in the string and surrounded by blanks or \fICharacter\fR\&\&. The resulting string has length \fINumber\fR\&\&.
.RE
.LP
.nf

.B
chars(Character, Number) -> String
.br
.fi
.br
.nf

.B
chars(Character, Number, Tail) -> String
.br
.fi
.br
.RS
.LP
Types:

.RS 3
Character = char()
.br
Number = integer() >= 0
.br
Tail = String = string()
.br
.RE
.RE
.RS
.LP
Returns a string consisting of \fINumber\fR\& characters \fICharacter\fR\&\&. Optionally, the string can end with string \fITail\fR\&\&.
.RE
.LP
.nf

.B
chr(String, Character) -> Index
.br
.fi
.br
.RS
.LP
Types:

.RS 3
String = string()
.br
Character = char()
.br
Index = integer() >= 0
.br
.RE
.RE
.RS
.LP
Returns the index of the first occurrence of \fICharacter\fR\& in \fIString\fR\&\&. Returns \fI0\fR\& if \fICharacter\fR\& does not occur\&.
.RE
.LP
.nf

.B
concat(String1, String2) -> String3
.br
.fi
.br
.RS
.LP
Types:

.RS 3
String1 = String2 = String3 = string()
.br
.RE
.RE
.RS
.LP
Concatenates \fIString1\fR\& and \fIString2\fR\& to form a new string \fIString3\fR\&, which is returned\&.
.RE
.LP
.nf

.B
copies(String, Number) -> Copies
.br
.fi
.br
.RS
.LP
Types:

.RS 3
String = Copies = string()
.br
Number = integer() >= 0
.br
.RE
.RE
.RS
.LP
Returns a string containing \fIString\fR\& repeated \fINumber\fR\& times\&.
.RE
.LP
.nf

.B
cspan(String, Chars) -> Length
.br
.fi
.br
.RS
.LP
Types:

.RS 3
String = Chars = string()
.br
Length = integer() >= 0
.br
.RE
.RE
.RS
.LP
Returns the length of the maximum initial segment of \fIString\fR\&, which consists entirely of characters not from \fIChars\fR\&\&.
.LP
\fIExample:\fR\&
.LP
.nf

> string:cspan("\\t    abcdef", " \\t").
0
.fi
.RE
.LP
.nf

.B
equal(String1, String2) -> boolean()
.br
.fi
.br
.RS
.LP
Types:

.RS 3
String1 = String2 = string()
.br
.RE
.RE
.RS
.LP
Returns \fItrue\fR\& if \fIString1\fR\& and \fIString2\fR\& are equal, otherwise \fIfalse\fR\&\&.
.RE
.LP
.nf

.B
join(StringList, Separator) -> String
.br
.fi
.br
.RS
.LP
Types:

.RS 3
StringList = [string()]
.br
Separator = String = string()
.br
.RE
.RE
.RS
.LP
Returns a string with the elements of \fIStringList\fR\& separated by the string in \fISeparator\fR\&\&.
.LP
\fIExample:\fR\&
.LP
.nf

> join(["one", "two", "three"], ", ").
"one, two, three"
.fi
.RE
.LP
.nf

.B
left(String, Number) -> Left
.br
.fi
.br
.nf

.B
left(String, Number, Character) -> Left
.br
.fi
.br
.RS
.LP
Types:

.RS 3
String = Left = string()
.br
Number = integer() >= 0
.br
Character = char()
.br
.RE
.RE
.RS
.LP
Returns \fIString\fR\& with the length adjusted in accordance with \fINumber\fR\&\&. The left margin is fixed\&. If \fIlength(String)\fR\& < \fINumber\fR\&, then \fIString\fR\& is padded with blanks or \fICharacter\fR\&s\&.
.LP
\fIExample:\fR\&
.LP
.nf

> string:left("Hello",10,$.).
"Hello....."
.fi
.RE
.LP
.nf

.B
len(String) -> Length
.br
.fi
.br
.RS
.LP
Types:

.RS 3
String = string()
.br
Length = integer() >= 0
.br
.RE
.RE
.RS
.LP
Returns the number of characters in \fIString\fR\&\&.
.RE
.LP
.nf

.B
rchr(String, Character) -> Index
.br
.fi
.br
.RS
.LP
Types:

.RS 3
String = string()
.br
Character = char()
.br
Index = integer() >= 0
.br
.RE
.RE
.RS
.LP
Returns the index of the last occurrence of \fICharacter\fR\& in \fIString\fR\&\&. Returns \fI0\fR\& if \fICharacter\fR\& does not occur\&.
.RE
.LP
.nf

.B
right(String, Number) -> Right
.br
.fi
.br
.nf

.B
right(String, Number, Character) -> Right
.br
.fi
.br
.RS
.LP
Types:

.RS 3
String = Right = string()
.br
Number = integer() >= 0
.br
Character = char()
.br
.RE
.RE
.RS
.LP
Returns \fIString\fR\& with the length adjusted in accordance with \fINumber\fR\&\&. The right margin is fixed\&. If the length of \fI(String)\fR\& < \fINumber\fR\&, then \fIString\fR\& is padded with blanks or \fICharacter\fR\&s\&.
.LP
\fIExample:\fR\&
.LP
.nf

> string:right("Hello", 10, $.).
".....Hello"
.fi
.RE
.LP
.nf

.B
rstr(String, SubString) -> Index
.br
.fi
.br
.RS
.LP
Types:

.RS 3
String = SubString = string()
.br
Index = integer() >= 0
.br
.RE
.RE
.RS
.LP
Returns the position where the last occurrence of \fISubString\fR\& begins in \fIString\fR\&\&. Returns \fI0\fR\& if \fISubString\fR\& does not exist in \fIString\fR\&\&.
.LP
\fIExample:\fR\&
.LP
.nf

> string:rstr(" Hello Hello World World ", "Hello World").
8
.fi
.RE
.LP
.nf

.B
span(String, Chars) -> Length
.br
.fi
.br
.RS
.LP
Types:

.RS 3
String = Chars = string()
.br
Length = integer() >= 0
.br
.RE
.RE
.RS
.LP
Returns the length of the maximum initial segment of \fIString\fR\&, which consists entirely of characters from \fIChars\fR\&\&.
.LP
\fIExample:\fR\&
.LP
.nf

> string:span("\\t    abcdef", " \\t").
5
.fi
.RE
.LP
.nf

.B
str(String, SubString) -> Index
.br
.fi
.br
.RS
.LP
Types:

.RS 3
String = SubString = string()
.br
Index = integer() >= 0
.br
.RE
.RE
.RS
.LP
Returns the position where the first occurrence of \fISubString\fR\& begins in \fIString\fR\&\&. Returns \fI0\fR\& if \fISubString\fR\& does not exist in \fIString\fR\&\&.
.LP
\fIExample:\fR\&
.LP
.nf

> string:str(" Hello Hello World World ", "Hello World").
8
.fi
.RE
.LP
.nf

.B
strip(String :: string()) -> string()
.br
.fi
.br
.nf

.B
strip(String, Direction) -> Stripped
.br
.fi
.br
.nf

.B
strip(String, Direction, Character) -> Stripped
.br
.fi
.br
.RS
.LP
Types:

.RS 3
String = Stripped = string()
.br
Direction = left | right | both
.br
Character = char()
.br
.RE
.RE
.RS
.LP
Returns a string, where leading and/or trailing blanks or a number of \fICharacter\fR\& have been removed\&. \fIDirection\fR\&, which can be \fIleft\fR\&, \fIright\fR\&, or \fIboth\fR\&, indicates from which direction blanks are to be removed\&. \fIstrip/1\fR\& is equivalent to \fIstrip(String, both)\fR\&\&.
.LP
\fIExample:\fR\&
.LP
.nf

> string:strip("...Hello.....", both, $.).
"Hello"
.fi
.RE
.LP
.nf

.B
sub_string(String, Start) -> SubString
.br
.fi
.br
.nf

.B
sub_string(String, Start, Stop) -> SubString
.br
.fi
.br
.RS
.LP
Types:

.RS 3
String = SubString = string()
.br
Start = Stop = integer() >= 1
.br
.RE
.RE
.RS
.LP
Returns a substring of \fIString\fR\&, starting at position \fIStart\fR\& to the end of the string, or to and including position \fIStop\fR\&\&.
.LP
\fIExample:\fR\&
.LP
.nf

sub_string("Hello World", 4, 8).
"lo Wo"
.fi
.RE
.LP
.nf

.B
substr(String, Start) -> SubString
.br
.fi
.br
.nf

.B
substr(String, Start, Length) -> SubString
.br
.fi
.br
.RS
.LP
Types:

.RS 3
String = SubString = string()
.br
Start = integer() >= 1
.br
Length = integer() >= 0
.br
.RE
.RE
.RS
.LP
Returns a substring of \fIString\fR\&, starting at position \fIStart\fR\&, and ending at the end of the string or at length \fILength\fR\&\&.
.LP
\fIExample:\fR\&
.LP
.nf

> substr("Hello World", 4, 5).
"lo Wo"
.fi
.RE
.LP
.nf

.B
sub_word(String, Number) -> Word
.br
.fi
.br
.nf

.B
sub_word(String, Number, Character) -> Word
.br
.fi
.br
.RS
.LP
Types:

.RS 3
String = Word = string()
.br
Number = integer()
.br
Character = char()
.br
.RE
.RE
.RS
.LP
Returns the word in position \fINumber\fR\& of \fIString\fR\&\&. Words are separated by blanks or \fICharacter\fR\&s\&.
.LP
\fIExample:\fR\&
.LP
.nf

> string:sub_word(" Hello old boy !",3,$o).
"ld b"
.fi
.RE
.LP
.nf

.B
to_float(String) -> {Float, Rest} | {error, Reason}
.br
.fi
.br
.RS
.LP
Types:

.RS 3
String = string()
.br
Float = float()
.br
Rest = string()
.br
Reason = no_float | not_a_list
.br
.RE
.RE
.RS
.LP
Argument \fIString\fR\& is expected to start with a valid text represented float (the digits are ASCII values)\&. Remaining characters in the string after the float are returned in \fIRest\fR\&\&.
.LP
\fIExample:\fR\&
.LP
.nf

> {F1,Fs} = string:to_float("1.0-1.0e-1"),
> {F2,[]} = string:to_float(Fs),
> F1+F2.
0.9
> string:to_float("3/2=1.5").
{error,no_float}
> string:to_float("-1.5eX").
{-1.5,"eX"}
.fi
.RE
.LP
.nf

.B
to_integer(String) -> {Int, Rest} | {error, Reason}
.br
.fi
.br
.RS
.LP
Types:

.RS 3
String = string()
.br
Int = integer()
.br
Rest = string()
.br
Reason = no_integer | not_a_list
.br
.RE
.RE
.RS
.LP
Argument \fIString\fR\& is expected to start with a valid text represented integer (the digits are ASCII values)\&. Remaining characters in the string after the integer are returned in \fIRest\fR\&\&.
.LP
\fIExample:\fR\&
.LP
.nf

> {I1,Is} = string:to_integer("33+22"),
> {I2,[]} = string:to_integer(Is),
> I1-I2.
11
> string:to_integer("0.5").
{0,".5"}
> string:to_integer("x=2").
{error,no_integer}
.fi
.RE
.LP
.nf

.B
to_lower(String) -> Result
.br
.fi
.br
.nf

.B
to_lower(Char) -> CharResult
.br
.fi
.br
.nf

.B
to_upper(String) -> Result
.br
.fi
.br
.nf

.B
to_upper(Char) -> CharResult
.br
.fi
.br
.RS
.LP
Types:

.RS 3
String = Result = \fBio_lib:latin1_string()\fR\&
.br
Char = CharResult = char()
.br
.RE
.RE
.RS
.LP
The specified string or character is case-converted\&. Notice that the supported character set is ISO/IEC 8859-1 (also called Latin 1); all values outside this set are unchanged
.RE
.LP
.nf

.B
tokens(String, SeparatorList) -> Tokens
.br
.fi
.br
.RS
.LP
Types:

.RS 3
String = SeparatorList = string()
.br
Tokens = [Token :: nonempty_string()]
.br
.RE
.RE
.RS
.LP
Returns a list of tokens in \fIString\fR\&, separated by the characters in \fISeparatorList\fR\&\&.
.LP
\fIExample:\fR\&
.LP
.nf

> tokens("abc defxxghix jkl", "x ").
["abc", "def", "ghi", "jkl"]
.fi
.LP
Notice that, as shown in this example, two or more adjacent separator characters in \fIString\fR\& are treated as one\&. That is, there are no empty strings in the resulting list of tokens\&.
.RE
.LP
.nf

.B
words(String) -> Count
.br
.fi
.br
.nf

.B
words(String, Character) -> Count
.br
.fi
.br
.RS
.LP
Types:

.RS 3
String = string()
.br
Character = char()
.br
Count = integer() >= 1
.br
.RE
.RE
.RS
.LP
Returns the number of words in \fIString\fR\&, separated by blanks or \fICharacter\fR\&\&.
.LP
\fIExample:\fR\&
.LP
.nf

> words(" Hello old boy!", $o).
4
.fi
.RE
.SH "NOTES"

.LP
Some of the general string functions can seem to overlap each other\&. The reason is that this string package is the combination of two earlier packages and all functions of both packages have been retained\&.
.LP

.RS -4
.B
Note:
.RE
Any undocumented functions in \fIstring\fR\& are not to be used\&.
