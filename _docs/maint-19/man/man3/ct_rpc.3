.TH ct_rpc 3 "common_test 1.14" "Ericsson AB" "Erlang Module Definition"
.SH NAME
ct_rpc \- Common Test specific layer on Erlang/OTP rpc.
.SH DESCRIPTION
.LP
\fICommon Test\fR\& specific layer on Erlang/OTP \fIrpc\fR\&\&.
.SH EXPORTS
.LP
.B
app_node(App, Candidates) -> NodeName
.br
.RS
.LP
Types:

.RS 3
App = atom()
.br
Candidates = [NodeName]
.br
NodeName = atom()
.br
.RE
.RE
.RS
.LP
From a set of candidate nodes determines which of them is running the application \fIApp\fR\&\&. If none of the candidate nodes is running \fIApp\fR\&, the function makes the test case calling this function to fail\&. This function is the same as calling \fIapp_node(App, Candidates, true)\fR\&\&.
.RE
.LP
.B
app_node(App, Candidates, FailOnBadRPC) -> NodeName
.br
.RS
.LP
Types:

.RS 3
App = atom()
.br
Candidates = [NodeName]
.br
NodeName = atom()
.br
FailOnBadRPC = true | false
.br
.RE
.RE
.RS
.LP
Same as \fB\fIct_rpc:app_node/2\fR\&\fR\&, except that argument \fIFailOnBadRPC\fR\& determines if the search for a candidate node is to stop if \fIbadrpc\fR\& is received at some point\&.
.RE
.LP
.B
app_node(App, Candidates, FailOnBadRPC, Cookie) -> NodeName
.br
.RS
.LP
Types:

.RS 3
App = atom()
.br
Candidates = [NodeName]
.br
NodeName = atom()
.br
FailOnBadRPC = true | false
.br
Cookie = atom()
.br
.RE
.RE
.RS
.LP
Same as \fB\fIct_rpc:app_node/2\fR\&\fR\&, except that argument \fIFailOnBadRPC\fR\& determines if the search for a candidate node is to stop if \fIbadrpc\fR\& is received at some point\&.
.LP
The cookie on the client node is set to \fICookie\fR\& for this \fIrpc\fR\& operation (used to match the server node cookie)\&.
.RE
.LP
.B
call(Node, Module, Function, Args) -> term() | {badrpc, Reason}
.br
.RS
.LP
Same as \fIcall(Node, Module, Function, Args, infinity)\fR\&\&.
.RE
.LP
.B
call(Node, Module, Function, Args, TimeOut) -> term() | {badrpc, Reason}
.br
.RS
.LP
Types:

.RS 3
Node = NodeName | {Fun, FunArgs}
.br
Fun = function()
.br
FunArgs = term()
.br
NodeName = atom()
.br
Module = atom()
.br
Function = atom()
.br
Args = [term()]
.br
Reason = timeout | term()
.br
.RE
.RE
.RS
.LP
Evaluates \fIapply(Module, Function, Args)\fR\& on the node \fINode\fR\&\&. Returns either whatever \fIFunction\fR\& returns, or \fI{badrpc, Reason}\fR\& if the remote procedure call fails\&. If \fINode\fR\& is \fI{Fun, FunArgs}\fR\&, applying \fIFun\fR\& to \fIFunArgs\fR\& is to return a node name\&.
.RE
.LP
.B
call(Node, Module, Function, Args, TimeOut, Cookie) -> term() | {badrpc, Reason}
.br
.RS
.LP
Types:

.RS 3
Node = NodeName | {Fun, FunArgs}
.br
Fun = function()
.br
FunArgs = term()
.br
NodeName = atom()
.br
Module = atom()
.br
Function = atom()
.br
Args = [term()]
.br
Reason = timeout | term()
.br
Cookie = atom()
.br
.RE
.RE
.RS
.LP
Evaluates \fIapply(Module, Function, Args)\fR\& on the node \fINode\fR\&\&. Returns either whatever \fIFunction\fR\& returns, or \fI{badrpc, Reason}\fR\& if the remote procedure call fails\&. If \fINode\fR\& is \fI{Fun, FunArgs}\fR\&, applying \fIFun\fR\& to \fIFunArgs\fR\& is to return a node name\&.
.LP
The cookie on the client node is set to \fICookie\fR\& for this \fIrpc\fR\& operation (used to match the server node cookie)\&.
.RE
.LP
.B
cast(Node, Module, Function, Args) -> ok
.br
.RS
.LP
Types:

.RS 3
Node = NodeName | {Fun, FunArgs}
.br
Fun = function()
.br
FunArgs = term()
.br
NodeName = atom()
.br
Module = atom()
.br
Function = atom()
.br
Args = [term()]
.br
Reason = timeout | term()
.br
.RE
.RE
.RS
.LP
Evaluates \fIapply(Module, Function, Args)\fR\& on the node \fINode\fR\&\&. No response is delivered and the process that makes the call is not suspended until the evaluation is completed as in the case of \fIcall/3,4\fR\&\&. If \fINode\fR\& is \fI{Fun, FunArgs}\fR\&, applying \fIFun\fR\& to \fIFunArgs\fR\& is to return a node name\&.
.RE
.LP
.B
cast(Node, Module, Function, Args, Cookie) -> ok
.br
.RS
.LP
Types:

.RS 3
Node = NodeName | {Fun, FunArgs}
.br
Fun = function()
.br
FunArgs = term()
.br
NodeName = atom()
.br
Module = atom()
.br
Function = atom()
.br
Args = [term()]
.br
Reason = timeout | term()
.br
Cookie = atom()
.br
.RE
.RE
.RS
.LP
Evaluates \fIapply(Module, Function, Args)\fR\& on the node \fINode\fR\&\&. No response is delivered and the process that makes the call is not suspended until the evaluation is completed as in the case of \fIcall/3,4\fR\&\&. If \fINode\fR\& is \fI{Fun, FunArgs}\fR\&, applying \fIFun\fR\& to \fIFunArgs\fR\& is to return a node name\&.
.LP
The cookie on the client node is set to \fICookie\fR\& for this \fIrpc\fR\& operation (used to match the server node cookie)\&.
.RE