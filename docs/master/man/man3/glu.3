.TH glu 3 "wx 1.8.3" "" "Erlang Module Definition"
.SH NAME
glu \-  A part of the standard OpenGL Utility api.
.SH DESCRIPTION
.LP
A part of the standard OpenGL Utility api\&. See \fBwww\&.khronos\&.org\fR\&
.LP
Booleans are represented by integers 0 and 1\&.
.SH "DATA TYPES"

.RS 2
.TP 2
.B
enum() = non_neg_integer():

.RS 2
.LP
See wx/include/gl\&.hrl or glu\&.hrl
.RE
.TP 2
.B
matrix() = \fBmatrix12()\fR\& | \fBmatrix16()\fR\&:

.TP 2
.B
matrix12() = {float(), float(), float(), float(), float(), float(), float(), float(), float(), float(), float(), float()}:

.TP 2
.B
matrix16() = {float(), float(), float(), float(), float(), float(), float(), float(), float(), float(), float(), float(), float(), float(), float(), float()}:

.TP 2
.B
mem() = binary() | tuple():

.RS 2
.LP
Memory block
.RE
.TP 2
.B
vertex() = {float(), float(), float()}:

.RE
.SH EXPORTS
.LP
.B
tesselate(Normal, Vs::[Vs]) -> {Triangles, VertexPos}
.br
.RS
.LP
Types:

.RS 3
Normal = \fBvertex()\fR\&
.br
Vs = \fBvertex()\fR\&
.br
Triangles = [integer()]
.br
VertexPos = binary()
.br
.RE
.RE
.RS
.LP
General purpose polygon triangulation\&. The first argument is the normal and the second a list of vertex positions\&. Returned is a list of indecies of the vertices and a binary (64bit native float) containing an array of vertex positions, it starts with the vertices in Vs and may contain newly created vertices in the end\&.
.RE
.LP
.B
build1DMipmapLevels(Target, InternalFormat, Width, Format, Type, Level, Base, Max, Data) -> integer()
.br
.RS
.LP
Types:

.RS 3
Target = \fBenum()\fR\&
.br
InternalFormat = integer()
.br
Width = integer()
.br
Format = \fBenum()\fR\&
.br
Type = \fBenum()\fR\&
.br
Level = integer()
.br
Base = integer()
.br
Max = integer()
.br
Data = binary()
.br
.RE
.RE
.RS
.LP
Builds a subset of one-dimensional mipmap levels
.LP
\fIglu:build1DMipmapLevels\fR\& builds a subset of prefiltered one-dimensional texture maps of decreasing resolutions called a mipmap\&. This is used for the antialiasing of texture mapped primitives\&.
.LP
See external documentation\&.
.RE
.LP
.B
build1DMipmaps(Target, InternalFormat, Width, Format, Type, Data) -> integer()
.br
.RS
.LP
Types:

.RS 3
Target = \fBenum()\fR\&
.br
InternalFormat = integer()
.br
Width = integer()
.br
Format = \fBenum()\fR\&
.br
Type = \fBenum()\fR\&
.br
Data = binary()
.br
.RE
.RE
.RS
.LP
Builds a one-dimensional mipmap
.LP
\fIglu:build1DMipmaps\fR\& builds a series of prefiltered one-dimensional texture maps of decreasing resolutions called a mipmap\&. This is used for the antialiasing of texture mapped primitives\&.
.LP
See external documentation\&.
.RE
.LP
.B
build2DMipmapLevels(Target, InternalFormat, Width, Height, Format, Type, Level, Base, Max, Data) -> integer()
.br
.RS
.LP
Types:

.RS 3
Target = \fBenum()\fR\&
.br
InternalFormat = integer()
.br
Width = integer()
.br
Height = integer()
.br
Format = \fBenum()\fR\&
.br
Type = \fBenum()\fR\&
.br
Level = integer()
.br
Base = integer()
.br
Max = integer()
.br
Data = binary()
.br
.RE
.RE
.RS
.LP
Builds a subset of two-dimensional mipmap levels
.LP
\fIglu:build2DMipmapLevels\fR\& builds a subset of prefiltered two-dimensional texture maps of decreasing resolutions called a mipmap\&. This is used for the antialiasing of texture mapped primitives\&.
.LP
See external documentation\&.
.RE
.LP
.B
build2DMipmaps(Target, InternalFormat, Width, Height, Format, Type, Data) -> integer()
.br
.RS
.LP
Types:

.RS 3
Target = \fBenum()\fR\&
.br
InternalFormat = integer()
.br
Width = integer()
.br
Height = integer()
.br
Format = \fBenum()\fR\&
.br
Type = \fBenum()\fR\&
.br
Data = binary()
.br
.RE
.RE
.RS
.LP
Builds a two-dimensional mipmap
.LP
\fIglu:build2DMipmaps\fR\& builds a series of prefiltered two-dimensional texture maps of decreasing resolutions called a mipmap\&. This is used for the antialiasing of texture-mapped primitives\&.
.LP
See external documentation\&.
.RE
.LP
.B
build3DMipmapLevels(Target, InternalFormat, Width, Height, Depth, Format, Type, Level, Base, Max, Data) -> integer()
.br
.RS
.LP
Types:

.RS 3
Target = \fBenum()\fR\&
.br
InternalFormat = integer()
.br
Width = integer()
.br
Height = integer()
.br
Depth = integer()
.br
Format = \fBenum()\fR\&
.br
Type = \fBenum()\fR\&
.br
Level = integer()
.br
Base = integer()
.br
Max = integer()
.br
Data = binary()
.br
.RE
.RE
.RS
.LP
Builds a subset of three-dimensional mipmap levels
.LP
\fIglu:build3DMipmapLevels\fR\& builds a subset of prefiltered three-dimensional texture maps of decreasing resolutions called a mipmap\&. This is used for the antialiasing of texture mapped primitives\&.
.LP
See external documentation\&.
.RE
.LP
.B
build3DMipmaps(Target, InternalFormat, Width, Height, Depth, Format, Type, Data) -> integer()
.br
.RS
.LP
Types:

.RS 3
Target = \fBenum()\fR\&
.br
InternalFormat = integer()
.br
Width = integer()
.br
Height = integer()
.br
Depth = integer()
.br
Format = \fBenum()\fR\&
.br
Type = \fBenum()\fR\&
.br
Data = binary()
.br
.RE
.RE
.RS
.LP
Builds a three-dimensional mipmap
.LP
\fIglu:build3DMipmaps\fR\& builds a series of prefiltered three-dimensional texture maps of decreasing resolutions called a mipmap\&. This is used for the antialiasing of texture-mapped primitives\&.
.LP
See external documentation\&.
.RE
.LP
.B
checkExtension(ExtName, ExtString) -> 0 | 1
.br
.RS
.LP
Types:

.RS 3
ExtName = string()
.br
ExtString = string()
.br
.RE
.RE
.RS
.LP
Determines if an extension name is supported
.LP
\fIglu:checkExtension\fR\& returns \fI?GLU_TRUE\fR\& if \fIExtName\fR\& is supported otherwise \fI?GLU_FALSE\fR\& is returned\&.
.LP
See external documentation\&.
.RE
.LP
.B
cylinder(Quad, Base, Top, Height, Slices, Stacks) -> ok
.br
.RS
.LP
Types:

.RS 3
Quad = integer()
.br
Base = float()
.br
Top = float()
.br
Height = float()
.br
Slices = integer()
.br
Stacks = integer()
.br
.RE
.RE
.RS
.LP
Draw a cylinder
.LP
\fIglu:cylinder\fR\& draws a cylinder oriented along the \fIz\fR\& axis\&. The base of the cylinder is placed at \fIz\fR\& = 0 and the top at z=height\&. Like a sphere, a cylinder is subdivided around the \fIz\fR\& axis into slices and along the \fIz\fR\& axis into stacks\&.
.LP
See external documentation\&.
.RE
.LP
.B
deleteQuadric(Quad) -> ok
.br
.RS
.LP
Types:

.RS 3
Quad = integer()
.br
.RE
.RE
.RS
.LP
Destroy a quadrics object
.LP
\fIglu:deleteQuadric\fR\& destroys the quadrics object (created with \fBglu:newQuadric/0\fR\& ) and frees any memory it uses\&. Once \fIglu:deleteQuadric\fR\& has been called, \fIQuad\fR\& cannot be used again\&.
.LP
See external documentation\&.
.RE
.LP
.B
disk(Quad, Inner, Outer, Slices, Loops) -> ok
.br
.RS
.LP
Types:

.RS 3
Quad = integer()
.br
Inner = float()
.br
Outer = float()
.br
Slices = integer()
.br
Loops = integer()
.br
.RE
.RE
.RS
.LP
Draw a disk
.LP
\fIglu:disk\fR\& renders a disk on the \fIz\fR\& = 0 plane\&. The disk has a radius of \fIOuter\fR\& and contains a concentric circular hole with a radius of \fIInner\fR\& \&. If \fIInner\fR\& is 0, then no hole is generated\&. The disk is subdivided around the \fIz\fR\& axis into slices (like pizza slices) and also about the \fIz\fR\& axis into rings (as specified by \fISlices\fR\& and \fILoops\fR\& , respectively)\&.
.LP
See external documentation\&.
.RE
.LP
.B
errorString(Error) -> string()
.br
.RS
.LP
Types:

.RS 3
Error = \fBenum()\fR\&
.br
.RE
.RE
.RS
.LP
Produce an error string from a GL or GLU error code
.LP
\fIglu:errorString\fR\& produces an error string from a GL or GLU error code\&. The string is in ISO Latin 1 format\&. For example, \fIglu:errorString\fR\&(\fI?GLU_OUT_OF_MEMORY\fR\&) returns the string \fIout of memory\fR\&\&.
.LP
See external documentation\&.
.RE
.LP
.B
getString(Name) -> string()
.br
.RS
.LP
Types:

.RS 3
Name = \fBenum()\fR\&
.br
.RE
.RE
.RS
.LP
Return a string describing the GLU version or GLU extensions
.LP
\fIglu:getString\fR\& returns a pointer to a static string describing the GLU version or the GLU extensions that are supported\&.
.LP
See external documentation\&.
.RE
.LP
.B
lookAt(EyeX, EyeY, EyeZ, CenterX, CenterY, CenterZ, UpX, UpY, UpZ) -> ok
.br
.RS
.LP
Types:

.RS 3
EyeX = float()
.br
EyeY = float()
.br
EyeZ = float()
.br
CenterX = float()
.br
CenterY = float()
.br
CenterZ = float()
.br
UpX = float()
.br
UpY = float()
.br
UpZ = float()
.br
.RE
.RE
.RS
.LP
Define a viewing transformation
.LP
\fIglu:lookAt\fR\& creates a viewing matrix derived from an eye point, a reference point indicating the center of the scene, and an \fIUP\fR\& vector\&.
.LP
See external documentation\&.
.RE
.LP
.B
newQuadric() -> integer()
.br
.RS
.LP
Create a quadrics object
.LP
\fIglu:newQuadric\fR\& creates and returns a pointer to a new quadrics object\&. This object must be referred to when calling quadrics rendering and control functions\&. A return value of 0 means that there is not enough memory to allocate the object\&.
.LP
See external documentation\&.
.RE
.LP
.B
ortho2D(Left, Right, Bottom, Top) -> ok
.br
.RS
.LP
Types:

.RS 3
Left = float()
.br
Right = float()
.br
Bottom = float()
.br
Top = float()
.br
.RE
.RE
.RS
.LP
Define a 2D orthographic projection matrix
.LP
\fIglu:ortho2D\fR\& sets up a two-dimensional orthographic viewing region\&. This is equivalent to calling \fBgl:ortho/6\fR\& with near=-1 and far=1\&.
.LP
See external documentation\&.
.RE
.LP
.B
partialDisk(Quad, Inner, Outer, Slices, Loops, Start, Sweep) -> ok
.br
.RS
.LP
Types:

.RS 3
Quad = integer()
.br
Inner = float()
.br
Outer = float()
.br
Slices = integer()
.br
Loops = integer()
.br
Start = float()
.br
Sweep = float()
.br
.RE
.RE
.RS
.LP
Draw an arc of a disk
.LP
\fIglu:partialDisk\fR\& renders a partial disk on the z=0 plane\&. A partial disk is similar to a full disk, except that only the subset of the disk from \fIStart\fR\& through \fIStart\fR\& + \fISweep\fR\& is included (where 0 degrees is along the +f2yf axis, 90 degrees along the +\fIx\fR\& axis, 180 degrees along the -\fIy\fR\& axis, and 270 degrees along the -\fIx\fR\& axis)\&.
.LP
See external documentation\&.
.RE
.LP
.B
perspective(Fovy, Aspect, ZNear, ZFar) -> ok
.br
.RS
.LP
Types:

.RS 3
Fovy = float()
.br
Aspect = float()
.br
ZNear = float()
.br
ZFar = float()
.br
.RE
.RE
.RS
.LP
Set up a perspective projection matrix
.LP
\fIglu:perspective\fR\& specifies a viewing frustum into the world coordinate system\&. In general, the aspect ratio in \fIglu:perspective\fR\& should match the aspect ratio of the associated viewport\&. For example, aspect=2\&.0 means the viewer\&'s angle of view is twice as wide in \fIx\fR\& as it is in \fIy\fR\&\&. If the viewport is twice as wide as it is tall, it displays the image without distortion\&.
.LP
See external documentation\&.
.RE
.LP
.B
pickMatrix(X, Y, DelX, DelY, Viewport) -> ok
.br
.RS
.LP
Types:

.RS 3
X = float()
.br
Y = float()
.br
DelX = float()
.br
DelY = float()
.br
Viewport = {integer(), integer(), integer(), integer()}
.br
.RE
.RE
.RS
.LP
Define a picking region
.LP
\fIglu:pickMatrix\fR\& creates a projection matrix that can be used to restrict drawing to a small region of the viewport\&. This is typically useful to determine what objects are being drawn near the cursor\&. Use \fIglu:pickMatrix\fR\& to restrict drawing to a small region around the cursor\&. Then, enter selection mode (with \fBgl:renderMode/1\fR\& ) and rerender the scene\&. All primitives that would have been drawn near the cursor are identified and stored in the selection buffer\&.
.LP
See external documentation\&.
.RE
.LP
.B
project(ObjX, ObjY, ObjZ, Model, Proj, View) -> {integer(), WinX::float(), WinY::float(), WinZ::float()}
.br
.RS
.LP
Types:

.RS 3
ObjX = float()
.br
ObjY = float()
.br
ObjZ = float()
.br
Model = \fBmatrix()\fR\&
.br
Proj = \fBmatrix()\fR\&
.br
View = {integer(), integer(), integer(), integer()}
.br
.RE
.RE
.RS
.LP
Map object coordinates to window coordinates
.LP
\fIglu:project\fR\& transforms the specified object coordinates into window coordinates using \fIModel\fR\& , \fIProj\fR\& , and \fIView\fR\& \&. The result is stored in \fIWinX\fR\& , \fIWinY\fR\& , and \fIWinZ\fR\& \&. A return value of \fI?GLU_TRUE\fR\& indicates success, a return value of \fI?GLU_FALSE\fR\& indicates failure\&.
.LP
See external documentation\&.
.RE
.LP
.B
quadricDrawStyle(Quad, Draw) -> ok
.br
.RS
.LP
Types:

.RS 3
Quad = integer()
.br
Draw = \fBenum()\fR\&
.br
.RE
.RE
.RS
.LP
Specify the draw style desired for quadrics
.LP
\fIglu:quadricDrawStyle\fR\& specifies the draw style for quadrics rendered with \fIQuad\fR\& \&. The legal values are as follows:
.LP
See external documentation\&.
.RE
.LP
.B
quadricNormals(Quad, Normal) -> ok
.br
.RS
.LP
Types:

.RS 3
Quad = integer()
.br
Normal = \fBenum()\fR\&
.br
.RE
.RE
.RS
.LP
Specify what kind of normals are desired for quadrics
.LP
\fIglu:quadricNormals\fR\& specifies what kind of normals are desired for quadrics rendered with \fIQuad\fR\& \&. The legal values are as follows:
.LP
See external documentation\&.
.RE
.LP
.B
quadricOrientation(Quad, Orientation) -> ok
.br
.RS
.LP
Types:

.RS 3
Quad = integer()
.br
Orientation = \fBenum()\fR\&
.br
.RE
.RE
.RS
.LP
Specify inside/outside orientation for quadrics
.LP
\fIglu:quadricOrientation\fR\& specifies what kind of orientation is desired for quadrics rendered with \fIQuad\fR\& \&. The \fIOrientation\fR\& values are as follows:
.LP
See external documentation\&.
.RE
.LP
.B
quadricTexture(Quad, Texture) -> ok
.br
.RS
.LP
Types:

.RS 3
Quad = integer()
.br
Texture = 0 | 1
.br
.RE
.RE
.RS
.LP
Specify if texturing is desired for quadrics
.LP
\fIglu:quadricTexture\fR\& specifies if texture coordinates should be generated for quadrics rendered with \fIQuad\fR\& \&. If the value of \fITexture\fR\& is \fI?GLU_TRUE\fR\&, then texture coordinates are generated, and if \fITexture\fR\& is \fI?GLU_FALSE\fR\&, they are not\&. The initial value is \fI?GLU_FALSE\fR\&\&.
.LP
See external documentation\&.
.RE
.LP
.B
scaleImage(Format, WIn, HIn, TypeIn, DataIn, WOut, HOut, TypeOut, DataOut) -> integer()
.br
.RS
.LP
Types:

.RS 3
Format = \fBenum()\fR\&
.br
WIn = integer()
.br
HIn = integer()
.br
TypeIn = \fBenum()\fR\&
.br
DataIn = binary()
.br
WOut = integer()
.br
HOut = integer()
.br
TypeOut = \fBenum()\fR\&
.br
DataOut = \fBmem()\fR\&
.br
.RE
.RE
.RS
.LP
Scale an image to an arbitrary size
.LP
\fIglu:scaleImage\fR\& scales a pixel image using the appropriate pixel store modes to unpack data from the source image and pack data into the destination image\&.
.LP
See external documentation\&.
.RE
.LP
.B
sphere(Quad, Radius, Slices, Stacks) -> ok
.br
.RS
.LP
Types:

.RS 3
Quad = integer()
.br
Radius = float()
.br
Slices = integer()
.br
Stacks = integer()
.br
.RE
.RE
.RS
.LP
Draw a sphere
.LP
\fIglu:sphere\fR\& draws a sphere of the given radius centered around the origin\&. The sphere is subdivided around the \fIz\fR\& axis into slices and along the \fIz\fR\& axis into stacks (similar to lines of longitude and latitude)\&.
.LP
See external documentation\&.
.RE
.LP
.B
unProject(WinX, WinY, WinZ, Model, Proj, View) -> {integer(), ObjX::float(), ObjY::float(), ObjZ::float()}
.br
.RS
.LP
Types:

.RS 3
WinX = float()
.br
WinY = float()
.br
WinZ = float()
.br
Model = \fBmatrix()\fR\&
.br
Proj = \fBmatrix()\fR\&
.br
View = {integer(), integer(), integer(), integer()}
.br
.RE
.RE
.RS
.LP
Map window coordinates to object coordinates
.LP
\fIglu:unProject\fR\& maps the specified window coordinates into object coordinates using \fIModel\fR\& , \fIProj\fR\& , and \fIView\fR\& \&. The result is stored in \fIObjX\fR\& , \fIObjY\fR\& , and \fIObjZ\fR\& \&. A return value of \fI?GLU_TRUE\fR\& indicates success; a return value of \fI?GLU_FALSE\fR\& indicates failure\&.
.LP
See external documentation\&.
.RE
.LP
.B
unProject4(WinX, WinY, WinZ, ClipW, Model, Proj, View, NearVal, FarVal) -> {integer(), ObjX::float(), ObjY::float(), ObjZ::float(), ObjW::float()}
.br
.RS
.LP
Types:

.RS 3
WinX = float()
.br
WinY = float()
.br
WinZ = float()
.br
ClipW = float()
.br
Model = \fBmatrix()\fR\&
.br
Proj = \fBmatrix()\fR\&
.br
View = {integer(), integer(), integer(), integer()}
.br
NearVal = float()
.br
FarVal = float()
.br
.RE
.RE
.RS
.LP
See \fBunProject/6\fR\&
.RE
.SH AUTHORS
.LP

.I
<>